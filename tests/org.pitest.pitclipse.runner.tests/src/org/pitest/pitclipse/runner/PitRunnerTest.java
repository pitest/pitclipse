/*******************************************************************************
 * Copyright 2012-2019 Phil Glover and contributors
 *  
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/

package org.pitest.pitclipse.runner;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toSet;
import static org.eclipse.core.runtime.FileLocator.getBundleFile;
import static org.hamcrest.CoreMatchers.hasItems;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.collection.IsEmptyCollection.empty;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.core.runtime.Platform;
import org.eclipse.osgi.internal.framework.EquinoxBundle;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Before;
import org.junit.Test;
import org.osgi.framework.Bundle;
import org.pitest.mutationtest.MutationResultListenerFactory;
import org.pitest.pitclipse.example.empty.EmptyClass;
import org.pitest.pitclipse.runner.results.ObjectFactory;
import org.pitest.pitclipse.runner.results.mutations.RecordingMutationsDispatcher;
import org.pitest.util.ServiceLoader;

/**
 * Tests the behavior of a {@link PitRunner}'s functions.
 */
// TODO Add more tests to ensure outputs generated by Pitest are OK
public class PitRunnerTest {

    /**
     * Where Eclipse and Maven will generate .class files
     */
    private static final String BUILD_OUTPUT_DIR = "target/classes";

    private static final List<String> PROJECTS = asList("project1", "project2");

    @Before
    public void clearMutations() {
        RecordingMutationsDispatcher.INSTANCE
            .dispatch(new ObjectFactory().createMutations());
    }

    @Test
    public void shouldRunPitest() throws IOException {
        PitRequest request = PitRequest.builder()
            .withPitOptions(
                options(
                    PitOptionsTest.class.getCanonicalName(),
                    asList("org.pitest.pitclipse.runner.*")))
            .withProjects(PROJECTS).build();
        PitResults results = new PitRunner().apply(request);
        assertThat(results, is(notNullValue()));
        assertThat(results.getHtmlResultFile(), is(aFileThatExists()));
        assertThat(results.getMutations(), is(notNullValue()));
        assertThat(results.getMutations().getMutation(), not(empty()));
        assertThat(results, is(serializable()));
    }

    @Test
    public void shouldRunPitestEvenWhenNoMutant() throws IOException {
        PitRequest request = PitRequest.builder()
            .withPitOptions(
                options(
                    EmptyClass.class.getCanonicalName(),
                    asList("org.pitest.pitclipse.example.empty.*")))
            .withProjects(PROJECTS).build();
        PitResults results = new PitRunner().apply(request);
        assertThat(results, is(notNullValue()));
        assertThat(results.getHtmlResultFile(), is(nullValue()));
        assertThat(results.getMutations(), is(notNullValue()));
        assertThat(results.getMutations().getMutation(), empty());
        assertThat(results, is(serializable()));
    }

    @Test 
    public void shouldFindAllAvailableMutationResultListeners() {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        Collection<MutationResultListenerFactory> factories = ServiceLoader.load(MutationResultListenerFactory.class, contextClassLoader);
        Set<String> factoriesName = factories.stream().map(f -> f.name()).collect(toSet());
        
        String[] expectedFactoriesName = new String[] {"HTML", "CSV", "XML", "PITCLIPSE_MUTATIONS", "PITCLIPSE_SUMMARY"};
        assertThat(factoriesName, hasItems(expectedFactoriesName));
    }

    private <T> Matcher<T> serializable() {
        return new TypeSafeMatcher<T>() {
            @Override
            protected boolean matchesSafely(T candidate) {
                try {
                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
                    new ObjectOutputStream(byteStream).writeObject(candidate);
                    new ObjectInputStream(new ByteArrayInputStream(byteStream.toByteArray())).readObject();
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("is serializable");
            }
        };
    }

    private Matcher<File> aFileThatExists() {
        return new TypeSafeMatcher<File>() {
            @Override
            public void describeTo(Description description) {
                description.appendText("file exists");
            }

            @Override
            protected boolean matchesSafely(File file) {
                return null != file && file.exists();
            }
        };
    }

    private static PitOptions options(String classUnderTest, List<String> classesToMutate) throws IOException {
        File srcDir = new File(System.getProperty("user.dir") + File.separator + "src");
        return PitOptions.builder()
            .withSourceDirectory(srcDir)
            .withClassUnderTest(classUnderTest)
            .withClassesToMutate(classesToMutate)
            .withClassPath(classPathWithPitestAndJUnit())
                       .build();
    }
    
    private static List<String> classPathWithPitestAndJUnit() throws IOException {
        final String jarDir = "lib";
        EquinoxBundle pitestBundle = (EquinoxBundle) Platform.getBundle("org.pitest");
        Bundle[] bundles = Platform.getBundle("org.eclipse.core.runtime").getBundleContext().getBundles();
        System.out.println("symbolic name: " + pitestBundle.getSymbolicName());
        List<EquinoxBundle> pitestWrappedBundles = Stream.of(bundles)
        	.filter(b -> b instanceof EquinoxBundle)
        	.map(b -> (EquinoxBundle) b)
        	.filter(b -> b.getSymbolicName().startsWith("wrapped.org.pitest"))
        	.collect(Collectors.toList());
        List<String> locations = pitestWrappedBundles.stream()
        	.map(b -> b.getLocation())
        	.collect(Collectors.toList());
    	// hack, exclude JUnit 5?
        locations.remove(locations.size() - 1);
        

        List<String> classPath = new ArrayList<>();
        
//        classPath.add(getBundleFile(pitestBundle).getCanonicalPath());

        classPath.add(getBundleFile(Platform.getBundle("org.pitest.pitclipse.runner")).getCanonicalPath());
        classPath.add(getBundleFile(Platform.getBundle("org.pitest.pitclipse.runner")).getCanonicalPath() + File.separator + BUILD_OUTPUT_DIR);
        
        for (Bundle bundle : pitestWrappedBundles) {
			classPath.add(getBundleFile(bundle).getCanonicalPath());
		}
        
        // Guava is needed
        classPath.add(getBundleFile(Platform.getBundle("com.google.guava")).getCanonicalPath());
        
        // Add .class files to mutate
        classPath.add(new File(BUILD_OUTPUT_DIR).getAbsolutePath());

        // Add JUnit dependency
        classPath.add(new File("lib/junit.jar").getAbsolutePath());

        return classPath;
    }
}
